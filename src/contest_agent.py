# src/contest_agent.py

# Importing required libraries for message handling and data validation
from langchain_core.messages import SystemMessage, HumanMessage
from pydantic import BaseModel
from src.create_llm_message import create_llm_message
from src.book_appointment import handle_appointment_request, book_appointment

# Data model for structuring the LLM's response
class ContestDecision(BaseModel):
    nextsteps: str # Stores the next steps or actions for the user
    decision: str  # Stores the decision type ('Info', 'URLform', 'Other')

# When ContestAgent object is created, it's initialized with a model. 
# The main entry point is the contest_agent method. You can see workflow.add_node for contest_agent node in graph.py

class ContestAgent:
    
    def __init__(self, model):
        """
        Initialize the ContestAgent with a ChatOpenAI model.
        
        :param model: An instance of the ChatOpenAI model used for generating responses.
        """
        self.model = model

    def get_contest_info(self) -> str:
        """
        Retrieve contest rules from a text file. Make sure contestrules.txt exists in the root directory.
        
        :return: A string containing the contest rules.
        """
        with open('contestrules.txt', 'r') as file:
            contest_rules = file.read()
        return contest_rules

    def book_appt(self):
        # Calls external function to fetch available appointment slots
        # This likely connects to a calendar or scheduling system
        available_slots = handle_appointment_request()
        # Debug print to see the available slots in the console
        print(available_slots)
        # Returns the list of available time slots
        return available_slots

    def get_available_slots(self, available_slots):
        # Creates a prompt template for the AI to format the available slots
        time_slot_prompt = f"""
         You are an appointment booking scheduler. Present the following slots in a brief, easy-to-read format. Keep 
         the message compact but always maintain a friendly, professional, and helpful tone throughout the interaction.

        Available slots: {available_slots}

        Instructions:
        1. List the slots in a clean and easy to read format
        2. Keep your message under 100 words
        3. Simply ask "Please choose a time slot."
        4. Based on these slots, simply ask the user to select any of the available slots. 
        """

        # Sends the prompt to the AI model to get a formatted response
        response = self.model.invoke(time_slot_prompt)
        # Returns just the content of the AI's response (the formatted slot list)
        return response.content

    def confirm_appointment(self):
        # Debug print to indicate appointment confirmation process
        print("Confirming the appointment")
        # Returns a confirmation message with next steps
        # Note: This seems incomplete as it doesn't include actual next steps
        response = "Appointment is confirmed. Here are the next steps:"
        return response


    def get_contest_url(self) -> str:
        """
        Read and return the contest form URL from a text file. Make sure contesturl.txt exists in the root directory

        :return: A string containing contest URL.
        """
        with open('contesturl.txt', 'r') as file:
            contest_url = file.read()
        return contest_url

    def generate_contest_response(self) -> str:
        """
        Generate a response for contest-related queries using the ChatOpenAI model.
        
        :param user_query: The original query from the user.
        :return: A string response generated by the language model.
        """
        contest_prompt = f"""
        You are a Sales Commissions expert. Users will ask you about how to start a SPIF or sales contest. Always maintain 
        a friendly, professional, and helpful tone throughout the interaction.

        Instructions:

        1. Determine the User's Needs:

            Decide whether the user requires:
                - Information about starting a SPIF (Sales Performance Incentive Fund) or sales contest (Decision: 'Info').
                - Book an appointment after the user confirms that they understand the rules (Decision: 'BookAppointment').
                - Confirm an appointment after the user confirms the appointment slot (Decision: 'ConfirmAppointment').
                - The URL to the contest form after the apppointment has been booked (Decision: 'URLform').
                - Other assistance or next steps (Decision: 'Other').
        
        2. Provide Appropriate Assistance Based on the Decision:

            a) If 'Info', offer detailed information on how to initiate a SPIF or sales contest.
            b) If 'BookAppointment', 
                - Check if the user has provided you their Full Name and Email Address.
                - If the user did not provide complete information ask them to provide Full Name and Email Address, 
                  letting them know that you need this information to book an appointment.
                - Provide the user information to book an appointment.
            c) If 'ConfirmAppointment', confirm that the appointment was booked.
            d) If 'URLform', provide the user with the URL to the contest form.
            e) If 'Other':
                - Give clear instructions on the next steps the user should take.
                - Explain what they should expect moving forward.
                - If no further action is required, politely thank the user and ask if they need help with anything else.
                - Include this information in the field labeled 'nextsteps'.
        
        3. Follow Contest Rules: Ensure all information and guidance comply with the contest rules as defined here: {self.get_contest_info()}

        """
        # Create a well-formatted message for LLM by passing the contest_prompt above to create_llm_messages
        llm_messages = create_llm_message(contest_prompt)

        # Invoke the model with the well-formatted prompt, including SystemMessage, HumanMessage, and AIMessage
        llm_response = self.model.with_structured_output(ContestDecision).invoke(llm_messages)
        
        full_response = llm_response
        
        return full_response


    def contest_agent(self, state: dict) -> dict:
        """
        Process user's contest-related questions and return appropriate responses.
        
        :param state: Dictionary containing conversation state and user's message
        :return: Dictionary containing:
            - lnode: Name of the current node ("contest_agent")
            - responseToUser: Contest info, URL, or next steps based on the decision
            - category: Type of response ("contest")
        """
        # Generate a response based on the user's initial message
        # Get AI's decision and recommended next steps
        llm_response = self.generate_contest_response()
        
        # Determine the appropriate response based on the LLM's decision
        if llm_response.decision == 'Info':
            user_response = self.get_contest_info()

        # Handle BookAppointment case
        elif llm_response.decision == 'BookAppointment':
            available_slots = self.book_appt()
            user_response = self.get_available_slots(available_slots)

        elif llm_response.decision == 'ConfirmAppointment':
            user_response = self.confirm_appointment()

        elif llm_response.decision == 'URLform':
            user_response = self.get_contest_url()

        else:  # Handle 'Other' case by sending AI's recommended next steps
            user_response = llm_response.nextsteps

        # Return the updated state with the generated response and the category set to 'contest'
        return {
            "lnode": "contest_agent", 
            "responseToUser": user_response,
            "category": "contest"
        }
