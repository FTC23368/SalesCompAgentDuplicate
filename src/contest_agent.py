# src/contest_agent.py

# Importing required libraries for message handling and data validation
from langchain_core.messages import SystemMessage, HumanMessage, AIMessage, BaseMessage
from pydantic import BaseModel
from src.create_llm_message import create_llm_message, create_llm_msg
from src.book_appointment import handle_appointment_request, book_appointment
from datetime import datetime
from typing import Optional
from src.send_email import send_email
import markdown2
from src.prompt_store import get_prompt

# Data model for structuring the LLM's response
class ContestDecision(BaseModel):
    nextsteps: str
    decision: str
    timeslot: Optional[str] = None
    email: Optional[str] = None
    name: Optional[str] = None

# When ContestAgent object is created, it's initialized with a model. 
# The main entry point is the contest_agent method. You can see workflow.add_node for contest_agent node in graph.py

class ContestAgent:
    
    def __init__(self, model):
        """
        Initialize the ContestAgent with a ChatOpenAI model.
        
        :param model: An instance of the ChatOpenAI model used for generating responses.
        """
        self.model = model

    def get_available_slots(self):
        # Calls external function to fetch available appointment slots
        # This connects to a calendar or scheduling system
        available_slots = handle_appointment_request()
        # Returns the list of available time slots
        return available_slots

    def list_available_slots(self, available_slots):
        # Gets a prompt from prompt_store.py template for the AI to format the available slots
        time_slot_prompt = get_prompt("timeslot").format(available_slots=available_slots)

        # Sends the prompt to the AI model to get a formatted response
        response = self.model.invoke(time_slot_prompt)
        # Returns just the content of the AI's response (the formatted slot list)
        return response.content

    def confirm_appointment(self, selected_slot, user_email):
        # Returns a confirmation message with next steps
        result = book_appointment(selected_slot, user_email)
        return result

    def get_contest_url(self) -> str:
        """
        Read and return the contest form URL from a text file. Make sure contesturl.txt exists in the root directory

        :return: A string containing contest URL.
        """
        with open('contesturl.txt', 'r') as file:
            contest_url = file.read()
        return contest_url

    def generate_contest_response(self, messageHistory: [BaseMessage]) -> str:
        """
        Generate a response for contest-related queries using the ChatOpenAI model.
        
        :param user_query: The original query from the user.
        :return: A string response generated by the language model.
        """
        # Get contest prompt from prompt_store.py
        contest_prompt = get_prompt("contest")

        # Create a well-formatted message for LLM by passing the contest_prompt above to create_llm_msg
        llm_messages = create_llm_msg(contest_prompt, messageHistory)

        # Invoke the model with the well-formatted prompt, including SystemMessage, HumanMessage, and AIMessage
        llm_response = self.model.with_structured_output(ContestDecision).invoke(llm_messages)
        
        full_response = llm_response
        
        return full_response

    def contest_agent(self, state: dict) -> dict:
        """
        Process user's contest-related questions and return appropriate responses.
        
        :param state: Dictionary containing conversation state and user's message
        :return: Dictionary containing:
            - lnode: Name of the current node ("contest_agent")
            - responseToUser: Contest info, URL, or next steps based on the decision
            - category: Type of response ("contest")
        """
        # Generate a response based on the user's initial message
        # Get AI's decision and recommended next steps
        llm_response = self.generate_contest_response(state['message_history'])
        llm_response.decision = llm_response.decision.replace("[", "").replace("]", "") #this line is for Groq LLM because it adds square brackets
        
        # Determine the appropriate response based on the LLM's decision
        # Handle BookAppointment case
        if llm_response.decision == 'BookAppointment':
            available_slots = self.get_available_slots()
            user_response = self.list_available_slots(available_slots)

            return {
                "lnode": "contest_agent", 
                "responseToUser": user_response,
                "category": "contest",
                "name": llm_response.name,
                "email": llm_response.email
            }

        elif llm_response.decision == 'ConfirmAppointment':
            # Convert the date string to datetime using strptime
            datetime_slot = datetime.strptime(llm_response.timeslot, "%A, %B %d, %Y, %I:%M %p") if llm_response.timeslot else None
            user_response = self.confirm_appointment(datetime_slot, llm_response.email)            
            # Send email with Intake Form URL to the user after confirming that the appointment has been booked
            subject = "Please complete the SPIF/Sales Contest Intake Form"
            html_content = markdown2.markdown(self.get_contest_url())
            send_email('malihajburney@gmail.com', llm_response.email, subject, html_content)

        elif llm_response.decision == 'AppointmentComplete':
            user_response = llm_response.nextsteps

        else:  # Handle 'Other' case by sending AI's recommended next steps, for example missing information.
            user_response = llm_response.nextsteps

        # Return the updated state with the generated response and the category set to 'contest'
        return {
            "lnode": "contest_agent", 
            "responseToUser": user_response,
            "category": "contest"
        }
