# src/contest_agent.py

# Importing required libraries for message handling and data validation
from langchain_core.messages import SystemMessage, HumanMessage, AIMessage, BaseMessage
from src.create_llm_message import create_llm_message, create_llm_msg
from src.send_email import send_email
from src.prompt_store import get_prompt
from typing import List


# When ContestAgent object is created, it's initialized with a model. 
# The main entry point is the contest_agent method. You can see workflow.add_node for contest_agent node in graph.py

class ContestAgent:
    
    def __init__(self, client, model, index, embedding_model):
        """
        Initialize the ContestAgent with a ChatOpenAI model.
        
        :param model: An instance of the ChatOpenAI model used for generating responses.
        """
        self.client = client
        self.index = index
        self.model = model
        self.embedding_model = embedding_model

    def retrieve_documents(self, query: str) -> List[str]:
        """
        Retrieve relevant documents based on the given query.
        
        :param query: User's query string
        :return: List of relevant document contents
        """
        # Generate an embedding for the query and retrieve relevant documents from Pinecone.
        embedding = self.client.embeddings.create(model=self.embedding_model, input=query).data[0].embedding
        results = self.index.query(vector=embedding, top_k=3, namespace="", include_metadata=True)
        
        retrieved_content = [r['metadata']['text'] for r in results['matches']]
        print(f"{query=},{retrieved_content=}")
        return retrieved_content


    def generate_contest_response(self, retrieved_content: List[str], user_query: str, messageHistory: list[BaseMessage]) -> str:
        """
        Generate a response for contest-related queries using the ChatOpenAI model.
        
        :param retrieved_content: List of relevant document contents
        :param user_query: The original query from the user.
        :return: A string response generated by the language model.
        """
        # Get contest prompt from prompt_store.py
        contest_prompt = get_prompt("contest").format(retrieved_content=retrieved_content)

        # Create a well-formatted message for LLM by passing the contest_prompt above to create_llm_msg
        llm_messages = create_llm_msg(contest_prompt, messageHistory)

        # Invoke the model with the well-formatted prompt, including SystemMessage, HumanMessage, and AIMessage
        llm_response = self.model.invoke(llm_messages)
        
        full_response = llm_response.content
        
        return full_response

    def contest_agent(self, state: dict) -> dict:
        """
        Process user's contest-related questions and return appropriate responses.
        
        :param state: Dictionary containing conversation state and user's message
        :return: Dictionary containing:
            - lnode: Name of the current node ("contest_agent")
            - responseToUser: Contest info, URL, or next steps based on the decision
            - category: Type of response ("contest")
        """
        # Handle SPIF or Sales Contest-related queries by retrieving relevant documents and generating a response.
        print("starting contest agent")
        retrieved_content = self.retrieve_documents(state['initialMessage'])
        
        full_response = self.generate_contest_response(retrieved_content, state['initialMessage'], state['message_history'])
        #llm_response.decision = llm_response.decision.replace("[", "").replace("]", "") #this line is for Groq LLM because it adds square brackets
        print("completed contest agent")

        # Return the updated state with the generated response and the category set to 'contest'
        return {
            "lnode": "contest_agent", 
            "responseToUser": full_response,
            "category": "contest"
        }